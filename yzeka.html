<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Femi</title>
    <link rel="icon" type="image/png" href="images/2.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome CDN for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Inter font for a clean look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align content to the top */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 800px; /* Maximum width */
            margin-top: 50px; /* Top margin */
            opacity: 0; /* Initially hidden */
            transform: translateY(20px); /* Slightly down initially */
            animation: fadeInSlideUpContainer 0.8s ease-out forwards; /* Apply animation */
        }
        /* Entrance animation for the main container */
        @keyframes fadeInSlideUpContainer {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .search-input {
            border: 2px solid #e2e8f0; /* Light border */
            transition: border-color 0.3s ease, box-shadow 0.3s ease; /* Added shadow transition */
        }
        .search-input:focus {
            border-color: #3b82f6; /* Blue border on focus */
            outline: none;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.3); /* More prominent shadow */
        }
        .search-button {
            background-color: #3b82f6; /* Blue button */
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.2s ease; /* Gölge geçişi eklendi */
        }
        .search-button:hover {
            background-color: #2563eb; /* Darker blue on hover */
            transform: translateY(-1px); /* Slight upward shift effect */
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15); /* More prominent shadow on hover */
        }
        .search-button:active {
            transform: translateY(0); /* Return to original state on click */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* Less shadow on click */
        }
        .result-card {
            background-color: #f8fafc; /* Result card background */
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.5s ease-out, transform 0.5s ease-out; /* Added animation transitions */
            /* Initial animation state will be set by JS */
        }
        .result-card:hover {
            transform: translateY(-5px); /* More prominent upward shift on hover */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1); /* More prominent shadow on hover */
        }
        .result-title {
            color: #1a202c; /* Title color */
            font-weight: 600;
        }
        .result-url {
            color: #3b82f6; /* URL color */
            font-size: 0.9em;
            word-break: break-all; /* For breaking long URLs */
        }
        .result-snippet {
            color: #4a5568; /* Description color */
            font-size: 0.95em;
            line-height: 1.5;
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Mobile responsive adjustments */
        @media (max-width: 640px) {
            .container {
                padding: 20px;
                margin-top: 20px;
            }
            .flex-col-mobile {
                flex-direction: column;
            }
            .search-button {
                width: 100%;
                margin-top: 10px;
            }
        }
        /* New icon styles */
        .icon {
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px; /* Space between text and icon */
        }
        .icon-search {
            width: 20px; /* Magnifying glass icon size */
            height: 20px;
            fill: white; /* White color */
            margin-right: 8px; /* Space between text and icon */
        }
        /* Style for Femi logo and camera icon */
        .femi-logo-text {
            font-size: 3rem; /* Femi text size */
            font-weight: 800;
            color: #1a202c;
            margin-right: 10px; /* Space between text and icon */
        }
        .camera-icon-img {
            height: 40px; /* Camera icon height */
            width: auto; /* Auto adjust width */
        }

        /* Website viewer overlay styles */
        .website-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* On top of everything else */
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .website-overlay.active {
            visibility: visible;
            opacity: 1;
        }

        .website-modal {
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            width: 90%;
            height: 90%;
            display: flex;
            flex-direction: column;
            position: relative;
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .website-overlay.active .website-modal {
            transform: scale(1);
        }

        .website-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 2rem;
            color: #333;
            cursor: pointer;
            z-index: 1001;
            transition: color 0.2s ease;
        }

        .website-modal-close:hover {
            color: #f00;
        }

        .website-iframe {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0 0 15px 15px;
        }

        /* New Speech Response Window Styles */
        .speech-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .speech-popup.active {
            visibility: visible;
            opacity: 1;
        }

        .speech-text {
            color: #ffffff;
            font-size: 4rem;
            font-weight: 900;
            text-align: center;
            padding: 20px;
            max-width: 90%;
            word-break: break-word;
            line-height: 1.2;
        }

        .speech-popup-close {
            position: absolute;
            top: 20px;
            right: 30px;
            background: none;
            border: none;
            font-size: 3rem;
            color: #ffffff;
            cursor: pointer;
            z-index: 1003;
            transition: color 0.2s ease;
        }

        .speech-popup-close:hover {
            color: #ff4d4d;
        }

        /* Animations */
        @keyframes slideInFromLeft {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutToRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .slide-in {
            animation: slideInFromLeft 0.5s ease-out forwards;
        }

        .slide-out {
            animation: slideOutToRight 0.3s ease-in forwards;
        }

        @media (max-width: 768px) {
            .speech-text {
                font-size: 2.5rem;
            }
            .speech-popup-close {
                font-size: 2rem;
                top: 10px;
                right: 15px;
            }
        }

        /* Control Button Styles */
        .control-button {
            background-color: #4a90e2; /* Blue */
            color: white;
            border-radius: 50%; /* Circular button */
            width: 60px; /* Fixed size */
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.2s ease;
        }
        .control-button:hover {
            background-color: #357ABD; /* Darker blue */
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        }
        .control-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .control-button.inactive {
            background-color: #cccccc; /* Gray for inactive */
            opacity: 0.7;
        }
        .control-button.inactive:hover {
            background-color: #bbbbbb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-4xl font-extrabold text-center text-gray-800 mb-6 flex items-center justify-center">
            <span class="femi-logo-text">Femi</span>
            <img src="images/2.png" alt="Kamera İkonu" class="camera-icon-img" onerror="this.onerror=null;this.src='https://placehold.co/40x40/FFD700/000000/png?text=%E2%97%8F%E2%96%A0%E2%96%A0'">
        </h1>
        <div class="flex flex-col sm:flex-row gap-3 mb-6">
            <input type="text" id="searchInput" placeholder="Femi'de ara..."
                   class="flex-grow p-3 rounded-lg search-input text-gray-700">
            <button id="searchButton"
                    class="p-3 rounded-lg text-white font-semibold shadow-md search-button flex items-center justify-center">
                <svg class="icon icon-search" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="currentColor"/>
                </svg>
                <span id="buttonText">Ara</span>
                <div id="loadingSpinner" class="loading-spinner hidden ml-2"></div>
            </button>
        </div>

        <!-- Yapay Zeka Yanıtı Bölümü -->
        <div id="aiResponse" class="space-y-4 mb-6">
            <!-- Yapay zeka yanıtı buraya gelecek -->
        </div>

        <div id="results" class="space-y-4">
            <!-- Arama sonuçları buraya gelecek -->
            <p id="noResultsMessage" class="text-center text-gray-500 hidden">Web sonuçları bulunamadı.</p>
        </div>

        <div id="errorMessage" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mt-4" role="alert">
            <strong class="font-bold">Hata!</strong>
            <span class="block sm:inline" id="errorText">Bir şeyler ters gitti. Lütfen tekrar deneyin.</span>
        </div>
        <div id="voiceStatus" class="text-center mt-4">Femi'yi bekliyor...</div>

        <!-- New Buttons Container -->
        <div class="flex justify-center gap-4 mt-8">
            <button id="toggleSpeechButton" class="control-button">
                <i class="fas fa-volume-up fa-2x"></i> <!-- Speaker icon -->
            </button>
            <button id="toggleSpeechPopupButton" class="control-button">
                <i class="fas fa-eye fa-2x"></i> <!-- Eye icon -->
            </button>
            <button id="toggleRecognitionButton" class="control-button">
                <i class="fas fa-microphone fa-2x"></i> <!-- Microphone icon -->
            </button>
        </div>
    </div>

    <!-- Web Sitesi Görüntüleyici Overlay -->
    <div id="websiteOverlay" class="website-overlay">
        <div class="website-modal">
            <button id="closeWebsiteButton" class="website-modal-close">&times;</button>
            <iframe id="websiteIframe" class="website-iframe"></iframe>
        </div>
    </div>

    <!-- New Speech Response Window -->
    <div id="speechPopup" class="speech-popup">
        <button id="closeSpeechButton" class="speech-popup-close">×</button>
        <span id="speechText" class="speech-text"></span>
    </div>

    <script type="module">
        // Firebase and other global variables are provided by the Canvas environment
        // Default values are used if these variables are not defined
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        // Ensure initialAuthToken variable is correctly assigned
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Get UI elements
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const aiResponseDiv = document.getElementById('aiResponse'); // New AI response div
        const resultsDiv = document.getElementById('results');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const buttonText = document.getElementById('buttonText');
        const noResultsMessage = document.getElementById('noResultsMessage');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');
        const voiceStatus = document.getElementById('voiceStatus'); // Voice status element

        // Website viewer elements
        const websiteOverlay = document.getElementById('websiteOverlay');
        const websiteIframe = document.getElementById('websiteIframe');
        const closeWebsiteButton = document.getElementById('closeWebsiteButton');

        // New speech response window elements
        const speechPopup = document.getElementById('speechPopup');
        const speechText = document.getElementById('speechText');
        const closeSpeechButton = document.getElementById('closeSpeechButton');

        // Global variables for speech recognition and response functions
        let recognition;
        let statusTimeout; // Timeout for clearing status message
        let currentUtterance = null; // To hold the current speech utterance object
        let displayTimeout = null; // Timeout for sentence display duration
        let isAIResponding = false; // Flag to indicate if AI is currently speaking
        let isRecognitionActive = false; // Flag to track if recognition is truly active
        let phrasesToSpeak = []; // Array to hold phrases for sequential speaking
        let currentPhraseIndex = 0; // Current index in phrasesToSpeak array

        // New control flags
        let isSpeechEnabled = true; // For text-to-speech output
        let isSpeechPopupVisible = true; // For the large text display popup
        let isRecognitionEnabled = false; // For speech-to-text recognition - DEFAULT TO FALSE

        // Get new button elements
        const toggleSpeechButton = document.getElementById('toggleSpeechButton');
        const toggleSpeechPopupButton = document.getElementById('toggleSpeechPopupButton');
        const toggleRecognitionButton = document.getElementById('toggleRecognitionButton');

        // Function to update button visuals
        function updateButtonStates() {
            toggleSpeechButton.classList.toggle('inactive', !isSpeechEnabled);
            toggleSpeechPopupButton.classList.toggle('inactive', !isSpeechPopupVisible);
            toggleRecognitionButton.classList.toggle('inactive', !isRecognitionEnabled);

            // Update icons based on state
            toggleSpeechButton.querySelector('i').className = isSpeechEnabled ? 'fas fa-volume-up fa-2x' : 'fas fa-volume-mute fa-2x';
            toggleSpeechPopupButton.querySelector('i').className = isSpeechPopupVisible ? 'fas fa-eye fa-2x' : 'fas fa-eye-slash fa-2x';
            toggleRecognitionButton.querySelector('i').className = isRecognitionEnabled ? 'fas fa-microphone fa-2x' : 'fas fa-microphone-slash fa-2x';
        }

        // Toggle functions for each service
        function toggleSpeechOutput() {
            isSpeechEnabled = !isSpeechEnabled;
            updateButtonStates();
            if (!isSpeechEnabled) {
                speechSynthesis.cancel(); // Stop any ongoing speech
                clearTimeout(displayTimeout); // Clear display timeout
                speechPopup.classList.remove('active'); // Hide popup immediately
                speechText.textContent = ''; // Clear text
                speechText.classList.remove('slide-in', 'slide-out');
                // If AI was speaking and speech is disabled, restart recognition if appropriate
                if (isAIResponding) {
                    isAIResponding = false; // Mark AI as finished
                    setTimeout(() => {
                        if (recognition && !isRecognitionActive && isRecognitionEnabled) {
                            recognition.start();
                            voiceStatus.textContent = "Dinleniyor...";
                        }
                    }, 200);
                }
            }
        }

        function toggleSpeechPopupVisibility() {
            isSpeechPopupVisible = !isSpeechPopupVisible;
            updateButtonStates();
            if (!isSpeechPopupVisible) {
                speechSynthesis.cancel(); // Stop any ongoing speech if popup is hidden
                clearTimeout(displayTimeout); // Clear display timeout
                speechPopup.classList.remove('active'); // Hide popup immediately
                speechText.textContent = ''; // Clear text
                speechText.classList.remove('slide-in', 'slide-out');
                // If AI was speaking and popup is manually hidden, ensure recognition restarts if appropriate
                if (isAIResponding) {
                    isAIResponding = false; // Mark AI as finished
                    setTimeout(() => {
                        if (recognition && !isRecognitionActive && isRecognitionEnabled) {
                            recognition.start();
                            voiceStatus.textContent = "Dinleniyor...";
                        }
                    }, 200);
                }
            }
            // If it becomes true, `speak` function will handle showing it next time.
        }

        function toggleRecognitionService() {
            isRecognitionEnabled = !isRecognitionEnabled;
            updateButtonStates();
            if (isRecognitionEnabled) {
                // If recognition was previously stopped and not active, try to start it
                if (recognition && !isRecognitionActive && !isAIResponding) {
                    recognition.start();
                    voiceStatus.textContent = "Dinleniyor...";
                } else if (isAIResponding) {
                    voiceStatus.textContent = "Femi yanıt veriyor..."; // Keep status if AI is speaking
                }
            } else {
                // Stop recognition if it's currently active
                if (recognition && isRecognitionActive) {
                    recognition.abort(); // Use abort to stop immediately
                    voiceStatus.textContent = "Ses tanıma kapalı.";
                }
            }
        }

        // Add event listeners to buttons
        toggleSpeechButton.addEventListener('click', toggleSpeechOutput);
        toggleSpeechPopupButton.addEventListener('click', toggleSpeechPopupVisibility);
        toggleRecognitionButton.addEventListener('click', toggleRecognitionService);

        // Show error message
        function displayError(message) {
            errorText.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        // Show website pop-up
        function showWebsitePopup(url) {
            websiteIframe.src = url;
            websiteOverlay.classList.add('active');
        }

        // Close website pop-up
        function closeWebsitePopup() {
            websiteOverlay.classList.remove('active');
            // iframe içeriğini temizle ve yüklemeyi durdur
            websiteIframe.src = 'about:blank';
        }

        // Add event listener to close button
        closeWebsiteButton.addEventListener('click', closeWebsitePopup);

        // Text-to-speech function
        function speak(text) {
            if (!isSpeechEnabled) {
                console.log("Speech output is disabled by user.");
                // If speech is disabled, but recognition was stopped because AI was speaking, restart it here.
                // This handles the case where user disables speech mid-search.
                if (isAIResponding) {
                    isAIResponding = false; // Mark AI as finished
                    setTimeout(() => {
                        if (recognition && !isRecognitionActive && isRecognitionEnabled) {
                            recognition.start();
                            voiceStatus.textContent = "Dinleniyor...";
                        }
                    }, 200);
                }
                return; // Do not speak if disabled
            }

            // Stop and clear previous speeches
            speechSynthesis.cancel();
            if (currentUtterance) {
                currentUtterance.onend = null;
                currentUtterance = null;
            }
            clearTimeout(displayTimeout); // Clear previous display timer

            // Stop speech recognition before speaking
            if (recognition && isRecognitionActive) { // Only abort if recognition is actually active
                recognition.abort(); // Immediately stop current recognition session
                isRecognitionActive = false; // Update flag
            }
            isAIResponding = true; // Set flag that AI is speaking
            voiceStatus.textContent = "Femi yanıt veriyor..."; // Update status

            const urlRegex = /(https?:\/\/[^\s]+)|((?:www\.)?[a-z0-9-]+\.[a-z]{2,6}(?:\/[^\s]*)?)/gi;
            const filteredText = text.replace(urlRegex, '');

            // Split into phrases (by punctuation or multiple spaces)
            phrasesToSpeak = filteredText.split(/(?<=[.!?])\s+|\s{2,}/).filter(p => p.trim() !== '');
            currentPhraseIndex = 0; // Reset phrase index for new speech

            // Only show the popup initially if it's enabled
            if (isSpeechPopupVisible) {
                speechPopup.classList.add('active');
            }
            processNextPhrase(); // Start with the first phrase
        }

        // Function to manage the sequence of phrases and animations
        function processNextPhrase() {
            if (currentPhraseIndex < phrasesToSpeak.length) {
                const phrase = phrasesToSpeak[currentPhraseIndex].trim();
                currentPhraseIndex++;

                // Only update speechText and apply animations if popup is visible
                if (isSpeechPopupVisible) {
                    speechText.classList.remove('slide-in', 'slide-out');
                    speechText.textContent = phrase;
                    speechText.classList.add('slide-in');
                } else {
                    speechText.textContent = ''; // Ensure text is cleared if popup is not visible
                }

                const words = phrase.split(/\s+/).filter(word => word.length > 0);
                const displayDuration = Math.max(words.length * 1000, 1500); // Total duration text is visible

                currentUtterance = new SpeechSynthesisUtterance(phrase);
                currentUtterance.lang = 'tr-TR'; // Ensure Turkish language

                currentUtterance.onend = () => {
                    // This callback means the *speech* has ended.
                    // The *display* of the text is controlled by the `displayTimeout`.
                    // No action needed here regarding display or next phrase, as `displayTimeout` will handle it.
                };

                currentUtterance.onerror = (event) => {
                    console.error('Speech synthesis error:', phrase, event.error);
                    // On error, the display timeout still needs to run to proceed to the next phrase.
                };

                speechSynthesis.speak(currentUtterance);

                clearTimeout(displayTimeout);
                displayTimeout = setTimeout(() => {
                    // This timeout fires when the total display duration for the current phrase is over.
                    // Now, trigger the slide-out animation and then proceed to the next phrase.
                    if (isSpeechPopupVisible) { // Only animate out if it was visible
                        speechText.classList.remove('slide-in');
                        speechText.classList.add('slide-out');
                        speechText.addEventListener('animationend', function handler(event) {
                            if (event.animationName === 'slideOutToRight') {
                                speechText.removeEventListener('animationend', handler);
                                processNextPhrase(); // Proceed to the next phrase in the sequence
                            }
                        }, { once: true });
                    } else {
                        processNextPhrase(); // If not visible, just proceed immediately
                    }
                }, displayDuration); // Use displayDuration for the timeout

            } else {
                // All phrases have been processed.
                setTimeout(() => {
                    if (isSpeechPopupVisible) { // Only remove active if it was visible
                        speechPopup.classList.remove('active');
                    }
                    speechText.textContent = '';
                    speechText.classList.remove('slide-in', 'slide-out');
                    isAIResponding = false; // AI finished speaking

                    // Small delay before restarting recognition to avoid race conditions
                    setTimeout(() => {
                        if (recognition && !isRecognitionActive && isRecognitionEnabled) { // Only restart if not already active and enabled
                            recognition.start();
                            voiceStatus.textContent = "Dinleniyor...";
                        }
                    }, 200); // 200ms delay
                }, 500); // Short delay before completely hiding popup
            }
        }

        // Close speech response window button (manual close)
        closeSpeechButton.addEventListener('click', () => {
            speechSynthesis.cancel(); // Stop speech
            if (currentUtterance) {
                currentUtterance.onend = null;
                currentUtterance = null;
            }
            clearTimeout(displayTimeout); // Clear display timer
            // Stop ongoing animations and reset classes
            speechText.classList.remove('slide-in', 'slide-out');
            speechPopup.classList.remove('active'); // Always hide on manual close
            speechText.textContent = '';
            isSpeechPopupVisible = false; // Ensure the toggle state is updated
            updateButtonStates(); // Update button visual

            if (isAIResponding) {
                isAIResponding = false;
                setTimeout(() => { // Add a small delay here too
                    if (recognition && !isRecognitionActive && isRecognitionEnabled) {
                        recognition.start();
                        voiceStatus.textContent = "Dinleniyor...";
                    }
                }, 200);
            }
        });


        // Initialize speech recognition
        function initializeSpeechRecognition() {
            // Check if browser supports SpeechRecognition API
            if (!('SpeechRecognition' in window || 'webkitSpeechRecognition' in window)) {
                voiceStatus.textContent = "Üzgünüm, tarayıcınız ses tanımayı desteklemiyor.";
                return;
            }

            // Check if browser supports microphone and media devices API
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                voiceStatus.textContent = "Tarayıcınız mikrofon erişimini desteklemiyor.";
                return;
            }

            // Check microphone permission status
            navigator.permissions.query({ name: 'microphone' }).then((permissionStatus) => {
                if (permissionStatus.state === 'granted') {
                    // If permission is already granted, start speech recognition directly
                    voiceStatus.textContent = "Mikrofon izni verildi. Dinleme başlatılıyor...";
                    startRecognition();
                } else if (permissionStatus.state === 'denied') {
                    // If permission is denied, tell the user to enable it manually
                    voiceStatus.textContent = "Mikrofon izni reddedildi. Sesli komutlar kullanılamıyor. Lütfen tarayıcı ayarlarınızdan manuel olarak etkinleştirin.";
                    // Removed speak() call to prevent "Speech synthesis error" in this scenario
                } else {
                    // If permission state is 'prompt' or 'undefined', request permission
                    voiceStatus.textContent = "Mikrofon izni bekleniyor...";
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(() => {
                            voiceStatus.textContent = "Mikrofon izni verildi. Dinleme başlatılıyor...";
                            startRecognition();
                        })
                        .catch((err) => {
                            console.error("Mikrofon izni reddedildi veya hata oluştu:", err);
                            voiceStatus.textContent = "Mikrofon izni reddedildi. Sesli komutlar kullanılamıyor. Lütfen tarayıcı ayarlarınızdan manuel olarak etkinleştirin.";
                            // Removed speak() call to prevent "Speech synthesis error" in this scenario
                        });
                }
            }).catch((err) => {
                console.error("Error querying microphone permission status:", err);
                voiceStatus.textContent = "Mikrofon izin durumu kontrol edilemedi. Lütfen tarayıcı ayarlarınızı kontrol edin.";
                // Removed speak() call to prevent "Speech synthesis error" in this scenario
            });

            function startRecognition() {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.continuous = true; // Continuous listening
                recognition.interimResults = false; // Do not show interim results, for more stable results
                recognition.lang = 'tr-TR'; // Set Turkish language

                // When speech recognition starts
                recognition.onstart = () => {
                    voiceStatus.textContent = "Dinleniyor...";
                    isRecognitionActive = true; // Set flag when recognition starts
                    console.log("Speech recognition started.");
                };

                // When speech recognition ends
                recognition.onend = () => {
                    console.log("Ses tanıma durdu.");
                    isRecognitionActive = false; // Clear flag when recognition stops
                    if (!isAIResponding && isRecognitionEnabled) { // Only restart if AI is not currently speaking and recognition is enabled
                        console.log("Ses tanıma otomatik olarak yeniden başlatılıyor.");
                        voiceStatus.textContent = "Dinleme durdu. Tekrar başlatılıyor...";
                        recognition.start();
                    } else if (!isRecognitionEnabled) {
                        voiceStatus.textContent = "Ses tanıma kapalı.";
                    } else if (isAIResponding) {
                        voiceStatus.textContent = "Femi yanıt veriyor..."; // Keep a status that indicates AI is speaking
                    }
                };

                // When speech recognition result comes
                recognition.onresult = async (event) => {
                    if (isAIResponding || !isRecognitionEnabled) { // If AI is speaking or recognition is disabled, ignore new voice commands
                        console.log("AI is speaking or recognition is disabled, ignoring new voice command.");
                        return;
                    }
                    let finalTranscript = '';

                    // Get only final results
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        const result = event.results[i];
                        if (result.isFinal) {
                            finalTranscript += result[0].transcript;
                        }
                    }

                    if (finalTranscript.length > 0) {
                        const transcript = finalTranscript.toLowerCase().trim();
                        console.log("Algılanan ses (final):", transcript);

                        // Clear previous status
                        if (statusTimeout) {
                            clearTimeout(statusTimeout);
                        }
                        
                        let queryToProcess = transcript; // Process the entire transcript

                        voiceStatus.textContent = `Algılandı: "${queryToProcess}" işleniyor...`;
                        
                        // Directly call the search function, allow AI to process the response
                        if (queryToProcess.length > 0) {
                            searchInput.value = queryToProcess; // Write to search box
                            performSearch(queryToProcess); // Call performSearch directly instead of clicking search button
                        }
                    }
                };

                // When speech recognition error occurs
                recognition.onerror = (event) => {
                    console.error("Speech recognition error:", event.error);
                    voiceStatus.textContent = `Hata: ${event.error}. Lütfen mikrofon iznini kontrol edin.`;
                    speak("Ses tanıma hatası oluştu.");
                    // Reset status message after a while even on error
                    if (statusTimeout) {
                        clearTimeout(statusTimeout);
                    }
                    statusTimeout = setTimeout(() => {
                        voiceStatus.textContent = "Dinleniyor...";
                    }, 5000); // Longer duration for error message
                };

                // Only start recognition initially if enabled
                if (isRecognitionEnabled) {
                    recognition.start();
                } else {
                    voiceStatus.textContent = "Ses tanıma kapalı.";
                }
            }
        }

        // Function to process voice commands (Gemini API integration)
        async function processVoiceCommand(command) {
            // This function will now directly perform a search.
            // Special cases like greetings will be handled by the AI.
            // We only handle website opening commands here.
            const openWebsiteKeywords = {
                "youtube aç": "https://www.youtube.com",
                "google aç": "https://www.google.com",
                "slow roads aç": "https://slowroads.io",
                "x aç": "https://x.com",
                "spotify aç": "https://www.spotify.com",
                "arama motorunu aç": "yzeka.html" // Redirect to search engine
            };

            for (const key in openWebsiteKeywords) {
                if (command.includes(key)) {
                    const url = openWebsiteKeywords[key];
                    const blockedDomains = ['youtube.com', 'google.com', 'facebook.com', 'instagram.com', 'twitter.com', 'x.com', 'spotify.com'];
                    const isBlocked = blockedDomains.some(domain => url.includes(domain));

                    voiceStatus.textContent = `"${key}" komutu algılandı. ${url} açılıyor...`;
                    speak(`${key} açılıyor.`);

                    if (isBlocked) {
                        let countdown = 3;
                        voiceStatus.textContent += ` Bu site güvenlik politikaları nedeniyle önizlenemiyor. Yeni sekmede açılıyor... ${countdown} saniye içinde.`;
                        const interval = setInterval(() => {
                            countdown--;
                            if (countdown > 0) {
                                countdownElement.textContent = `Bu site güvenlik politikaları nedeniyle önizlenemiyor. Yeni sekmede açılıyor... ${countdown} saniye içinde.`;
                            } else {
                                clearInterval(interval);
                                window.open(url, '_blank');
                                countdownElement.textContent = `Bu site güvenlik politikaları nedeniyle yeni sekmede açıldı.`;
                            }
                        }, 1000);
                    } else {
                        // If redirecting to yzeka.html, redirect directly
                        if (url === 'yzeka.html') {
                            window.location.href = url;
                        } else {
                            showWebsitePopup(url); // Show pop-up for other sites
                        }
                    }
                    return true; // Command handled
                }
            }
            return false; // Command not specifically handled
        }


        // Arama fonksiyonu
        async function performSearch(voiceQuery = null) { // voiceQuery parameter added
            const query = voiceQuery || searchInput.value.trim(); // Use voice query if available, otherwise get from input
            if (!query) {
                displayError("Lütfen bir arama terimi girin.");
                // Reset button state
                searchButton.disabled = false;
                buttonText.classList.remove('hidden');
                loadingSpinner.classList.add('hidden');
                return;
            }

            // UI updates when search starts
            searchButton.disabled = true;
            buttonText.classList.add('hidden');
            loadingSpinner.classList.remove('hidden');
            resultsDiv.innerHTML = ''; // Clear previous web results
            aiResponseDiv.innerHTML = ''; // Clear previous AI response
            noResultsMessage.classList.add('hidden');
            errorMessage.classList.add('hidden');
            voiceStatus.textContent = `"${query}" için yanıt aranıyor...`;
            
            // Check for Easter Egg
            if (query.toLowerCase() === "emirtru") {
                const easterEggText = "O benim sahibimin nicki sen sahibim değilsin!";
                aiResponseDiv.innerHTML = `
                    <div class="result-card bg-blue-50 border-blue-200">
                        <h3 class="result-title text-blue-800 text-xl mb-2">✨ Yapay Zeka Yanıtı</h3>
                        <p class="result-snippet text-blue-700">${easterEggText}</p>
                    </div>
                `;
                speak(easterEggText);
                // Reset UI after Easter Egg response
                searchButton.disabled = false;
                buttonText.classList.remove('hidden');
                loadingSpinner.classList.add('hidden');
                searchInput.value = '';
                voiceStatus.textContent = "Dinleniyor..."; // Ready for next command
                return; // Stop further processing for Easter Egg
            }


            speak("Yanıt aranıyor.");


            try {
                // 1. Generate AI Response (using Gemini API)
                aiResponseDiv.innerHTML = `
                    <div class="result-card bg-blue-50 border-blue-200">
                        <h3 class="result-title text-blue-800 text-xl mb-2">✨ Yapay Zeka Yanıtı</h3>
                        <p class="text-center text-gray-500">Yapay zeka yanıtı oluşturuluyor...</p>
                    </div>
                `;
                let chatHistory = [];
                // New instructions added to AI:
                // - Provide a medium-length, informative response.
                // - If asked who you are, respond "I am Femi."
                // - State that you do not have image generation capabilities.
                // - When receiving a command to open/visit a website (e.g., "open YouTube", "go to Google", "open slow roads", "open x"), the response should only be the URL of that website (e.g., "https://www.youtube.com", "https://www.google.com", "https://slowroads.io", "https://x.com"). Do not add any other text. Just provide the URL.
                // - In other cases, provide a short, informative, and concise response to the user's search query.
                chatHistory.push({ role: "user", parts: [{ text: `Çok uzun yanıtlar verme, kısa ve öz ol. Eğer kim olduğun sorulursa, "Ben Femi." diye yanıt ver. Görsel oluşturma veya medya işleme yeteneğim olmadığını unutma. Eğer bir web sitesi açma veya ziyaret etme komutu alırsan (örn: "YouTube aç", "Google'a git", "slow roads aç", "x aç"), yanıtın sadece o web sitesinin URL'si olsun (örn: "https://www.youtube.com", "https://www.google.com", "https://slowroads.io", "https://x.com"). Başka hiçbir metin ekleme. Sadece URL'yi ver. Kullanıcının arama sorgusuna kısa, bilgilendirici ve özet bir yanıt ver: "${query}"` }] });
                const payload = { contents: chatHistory };
                // Paste your Gemini API key here.
                const apiKey = "AIzaSyAng0nZ5N8ZyQmNLkVhf0HZbziVXBa_Xbw";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        let aiText = result.candidates[0].content.parts[0].text;
                        // Add an additional sentence to the AI response
                        aiText += " İstediğini sor, konuşmaktan çekinme.";

                        // Search for URL in AI response
                        // Catch both http/https and www-starting URLs, as well as domain.tld format URLs
                        const urlRegex = /(https?:\/\/[^\s]+)|((?:www\.)?[a-z0-9-]+\.[a-z]{2,6}(?:\/[^\s]*)?)/gi;
                        const foundUrls = aiText.match(urlRegex);

                        let suggestedUrl = null;
                        if (foundUrls && foundUrls.length > 0) {
                            suggestedUrl = foundUrls[0];
                            // If URL does not start with http or https, add https
                            if (!suggestedUrl.startsWith('http://') && !suggestedUrl.startsWith('https://')) {
                                suggestedUrl = 'https://' + suggestedUrl;
                            }
                            console.log("Detected URL:", suggestedUrl); // Log the detected URL to console

                            // Known sites that cannot be displayed in iframe
                            const blockedDomains = ['youtube.com', 'google.com', 'facebook.com', 'instagram.com', 'twitter.com', 'x.com', 'spotify.com'];
                            const isBlocked = blockedDomains.some(domain => suggestedUrl.includes(domain));

                            // Always display AI response
                            aiResponseDiv.innerHTML = `
                                <div class="result-card bg-blue-50 border-blue-200">
                                    <h3 class="result-title text-blue-800 text-xl mb-2">✨ Yapay Zeka Yanıtı</h3>
                                    <p class="result-snippet text-blue-700">${aiText}</p>
                                </div>
                            `;
                            speak(aiText); // Speak AI response

                            // If site is blocked, open in new tab, otherwise show in pop-up
                            if (isBlocked) {
                                let countdown = 3;
                                aiResponseDiv.innerHTML += `
                                    <p id="countdownMessage" class="mt-3 text-gray-600">Bu site güvenlik politikaları nedeniyle önizlenemiyor. Yeni sekmede açılıyor... ${countdown} saniye içinde.</p>
                                `;
                                const countdownElement = document.getElementById('countdownMessage');

                                const interval = setInterval(() => {
                                    countdown--;
                                    if (countdown > 0) {
                                        countdownElement.textContent = `Bu site güvenlik politikaları nedeniyle önizlenemiyor. Yeni sekmede açılıyor... ${countdown} saniye içinde.`;
                                    } else {
                                        clearInterval(interval);
                                        window.open(suggestedUrl, '_blank');
                                        countdownElement.textContent = `Bu site güvenlik politikaları nedeniyle yeni sekmede açıldı.`;
                                    }
                                }, 1000);

                            } else {
                                showWebsitePopup(suggestedUrl); // If URL found, directly show pop-up
                            }
                        } else {
                            aiResponseDiv.innerHTML = `
                                <div class="result-card bg-blue-50 border-blue-200">
                                    <h3 class="result-title text-blue-800 text-xl mb-2">✨ Yapay Zeka Yanıtı</h3>
                                    <p class="result-snippet text-blue-700">${aiText}</p>
                                </div>
                            `;
                            speak(aiText); // Speak AI response
                        }
                    } else {
                        aiResponseDiv.innerHTML = '<p class="text-center text-gray-500">AI response could not be retrieved.</p>';
                    }
                } catch (aiError) {
                    console.error("AI response error:", aiError);
                    // If API call fails, show mock response
                    aiResponseDiv.innerHTML = `
                        <div class="result-card bg-blue-50 border-blue-200">
                            <h3 class="result-title text-blue-800 text-xl mb-2">✨ Yapay Zeka Yanıtı (Mock)</h3>
                            <p class="result-snippet text-blue-700">Merhaba! Ben Femi. Sorgunla ilgili bilgi veremiyorum çünkü yapay zeka servisine erişilemiyor. Lütfen API anahtarını kontrol et ve daha sonra tekrar dene. Eğer bir web sitesi önerisi bekliyorsan, şu an için doğrudan açamıyorum.</p>
                        </div>
                    `;
                    speak("Üzgünüm, yapay zeka yanıtı alınamadı. Lütfen daha sonra tekrar deneyin.");
                }

                // 2. Web Arama Sonuçları (google_search aracı kullanarak)
                if (typeof google_search !== 'undefined' && typeof google_search.search === 'function') {
                    const searchResults = await google_search.search(queries=[query, query + " search"]);

                    if (searchResults && searchResults.length > 0 && searchResults[0].results) {
                        const results = searchResults[0].results;
                        if (results.length === 0) {
                            noResultsMessage.classList.remove('hidden');
                        } else {
                            results.forEach((result, index) => {
                                const resultCard = document.createElement('div');
                                // Added initial classes for animation
                                resultCard.className = 'result-card opacity-0 translate-y-5 transition-all duration-500 ease-out';

                                const title = document.createElement('h3');
                                title.className = 'result-title text-lg mb-1';
                                title.textContent = result.source_title || 'No Title';

                                const url = document.createElement('a');
                                url.className = 'result-url block mb-2';
                                url.href = result.url || '#';
                                url.target = '_blank'; // Open in new tab
                                url.textContent = result.url || 'No URL';

                                const snippet = document.createElement('p');
                                snippet.className = 'result-snippet';
                                snippet.textContent = result.snippet || 'Description not available.';

                                resultCard.appendChild(title);
                                resultCard.appendChild(url);
                                resultCard.appendChild(snippet);
                                resultsDiv.appendChild(resultCard);

                                // Start animation for each card with a slight delay
                                setTimeout(() => {
                                    resultCard.classList.remove('opacity-0', 'translate-y-5');
                                    resultCard.classList.add('opacity-100', 'translate-y-0');
                                }, index * 100); // 100ms delay for each card
                            });
                        }
                    } else {
                        noResultsMessage.classList.remove('hidden');
                    }
                } else {
                    resultsDiv.innerHTML = '';
                }

            } catch (mainError) {
                console.error("General search error:", mainError);
                displayError(mainError.message || "A general error occurred during search. Please try again.");
            } finally {
                // UI updates when search ends
                searchButton.disabled = false;
                buttonText.classList.remove('hidden');
                loadingSpinner.classList.add('hidden');
                // Clear search input
                searchInput.value = '';
                console.log("performSearch finished, button re-enabled."); // To check if function finished
            }
        }

        // Listen for click event on search button
        // Changed to use an arrow function to prevent the event object from being passed as voiceQuery
        searchButton.addEventListener('click', () => performSearch());

        // Perform search on Enter key press
        searchInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                performSearch();
            }
        });

        // Initial state update when page loads
        window.addEventListener('load', () => {
            initializeSpeechRecognition();
            updateButtonStates(); // Set initial button states
        });
    </script>
</body>
</html>
