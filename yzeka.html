<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Femi</title>
    <link rel="icon" type="image/png" href="images/2.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter font for a clean look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align content to the top */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            overflow-x: hidden; /* Prevent horizontal scrolling */
        }
        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 800px; /* Maximum width */
            margin-top: 50px; /* Top margin */
            opacity: 0; /* Initially hidden */
            transform: translateY(20px); /* Slightly down initially */
            animation: fadeInSlideUpContainer 0.8s ease-out forwards; /* Apply animation */
        }
        /* Entrance animation for the main container */
        @keyframes fadeInSlideUpContainer {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .search-input {
            border: 2px solid #e2e8f0; /* Light border */
            transition: border-color 0.3s ease, box-shadow 0.3s ease; /* Added shadow transition */
        }
        .search-input:focus {
            border-color: #3b82f6; /* Blue border on focus */
            outline: none;
            box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.3); /* More prominent shadow */
        }
        .search-button {
            background-color: #3b82f6; /* Blue button */
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.2s ease; /* Added shadow transition */
        }
        .search-button:hover {
            background-color: #2563eb; /* Darker blue on hover */
            transform: translateY(-1px); /* Slight upward shift effect */
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15); /* More prominent shadow on hover */
        }
        .search-button:active {
            transform: translateY(0); /* Return to original state on click */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); /* Less shadow on click */
        }
        .result-card {
            background-color: #f8fafc; /* Result card background */
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.5s ease-out, transform 0.5s ease-out; /* Added animation transitions */
            /* Initial animation state will be set by JS */
        }
        .result-card:hover {
            transform: translateY(-5px); /* More prominent upward shift on hover */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1); /* More prominent shadow on hover */
        }
        .result-title {
            color: #1a202c; /* Title color */
            font-weight: 600;
        }
        .result-url {
            color: #3b82f6; /* URL color */
            font-size: 0.9em;
            word-break: break-all; /* For breaking long URLs */
        }
        .result-snippet {
            color: #4a5568; /* Description color */
            font-size: 0.95em;
            line-height: 1.5;
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Mobile responsive adjustments */
        @media (max-width: 640px) {
            .container {
                padding: 20px;
                margin-top: 20px;
            }
            .flex-col-mobile {
                flex-direction: column;
            }
            .search-button {
                width: 100%;
                margin-top: 10px;
            }
        }
        /* New icon styles */
        .icon {
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px; /* Space between text and icon */
        }
        .icon-search {
            width: 20px; /* Magnifying glass icon size */
            height: 20px;
            fill: white; /* White color */
            margin-right: 8px; /* Space between text and icon */
        }
        /* Style for Femi logo and camera icon */
        .femi-logo-text {
            font-size: 3rem; /* Femi text size */
            font-weight: 800;
            color: #1a202c;
            margin-right: 10px; /* Space between text and icon */
        }
        .camera-icon-img {
            height: 40px; /* Camera icon height */
            width: auto; /* Auto adjust width */
        }

        /* Website viewer overlay styles */
        .website-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent black background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* On top of everything else */
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .website-overlay.active {
            visibility: visible;
            opacity: 1;
        }

        .website-modal {
            background-color: #fff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            width: 90%;
            height: 90%;
            display: flex;
            flex-direction: column;
            position: relative;
            transform: scale(0.8);
            transition: transform 0.3s ease;
        }

        .website-overlay.active .website-modal {
            transform: scale(1);
        }

        .website-modal-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 2rem;
            color: #333;
            cursor: pointer;
            z-index: 1001;
            transition: color 0.2s ease;
        }

        .website-modal-close:hover {
            color: #f00;
        }

        .website-iframe {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 0 0 15px 15px;
        }

        /* New Speech Response Window Styles */
        .speech-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .speech-popup.active {
            visibility: visible;
            opacity: 1;
        }

        .speech-text {
            color: #ffffff;
            font-size: 4rem;
            font-weight: 900;
            text-align: center;
            padding: 20px;
            max-width: 90%;
            word-break: break-word;
            line-height: 1.2;
        }

        .speech-popup-close {
            position: absolute;
            top: 20px;
            right: 30px;
            background: none;
            border: none;
            font-size: 3rem;
            color: #ffffff;
            cursor: pointer;
            z-index: 1003;
            transition: color 0.2s ease;
        }

        .speech-popup-close:hover {
            color: #ff4d4d;
        }

        /* Animations */
        @keyframes slideInFromLeft {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutToRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .slide-in {
            animation: slideInFromLeft 0.5s ease-out forwards;
        }

        .slide-out {
            animation: slideOutToRight 0.3s ease-in forwards;
        }

        @media (max-width: 768px) {
            .speech-text {
                font-size: 2.5rem;
            }
            .speech-popup-close {
                font-size: 2rem;
                top: 10px;
                right: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-4xl font-extrabold text-center text-gray-800 mb-6 flex items-center justify-center">
            <span class="femi-logo-text">Femi</span>
            <img src="images/2.png" alt="Camera Icon" class="camera-icon-img" onerror="this.onerror=null;this.src='https://placehold.co/40x40/FFD700/000000/png?text=%E2%97%8F%E2%96%A0%E2%96%A0'">
        </h1>
        <div class="flex flex-col sm:flex-row gap-3 mb-6">
            <input type="text" id="searchInput" placeholder="Femi'de ara..."
                   class="flex-grow p-3 rounded-lg search-input text-gray-700">
            <button id="searchButton"
                    class="p-3 rounded-lg text-white font-semibold shadow-md search-button flex items-center justify-center">
                <svg class="icon icon-search" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" fill="currentColor"/>
                </svg>
                <span id="buttonText">Ara</span>
                <div id="loadingSpinner" class="loading-spinner hidden ml-2"></div>
            </button>
        </div>

        <div id="aiResponse" class="space-y-4 mb-6">
            </div>

        <div id="results" class="space-y-4">
            <p id="noResultsMessage" class="text-center text-gray-500 hidden">Web sonuçları bulunamadı.</p>
        </div>

        <div id="errorMessage" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mt-4" role="alert">
            <strong class="font-bold">Hata!</strong>
            <span class="block sm:inline" id="errorText">Bir şeyler ters gitti. Lütfen tekrar deneyin.</span>
        </div>
        <div id="voiceStatus" class="text-center mt-4">Femi'yi bekliyor...</div>
    </div>

    <div id="websiteOverlay" class="website-overlay">
        <div class="website-modal">
            <button id="closeWebsiteButton" class="website-modal-close">×</button>
            <iframe id="websiteIframe" class="website-iframe"></iframe>
        </div>
    </div>

    <!-- New Speech Response Window -->
    <div id="speechPopup" class="speech-popup">
        <button id="closeSpeechButton" class="speech-popup-close">×</button>
        <span id="speechText" class="speech-text"></span>
    </div>

    <script type="module">
        // Firebase and other global variables are provided by the Canvas environment
        // Default values are used if these variables are not defined
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        // Ensure initialAuthToken variable is correctly assigned
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Get UI elements
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const aiResponseDiv = document.getElementById('aiResponse'); // New AI response div
        const resultsDiv = document.getElementById('results');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const buttonText = document.getElementById('buttonText');
        const noResultsMessage = document.getElementById('noResultsMessage');
        const errorMessage = document.getElementById('errorMessage');
        const errorText = document.getElementById('errorText');
        const voiceStatus = document.getElementById('voiceStatus'); // Voice status element

        // Website viewer elements
        const websiteOverlay = document.getElementById('websiteOverlay');
        const websiteIframe = document.getElementById('websiteIframe');
        const closeWebsiteButton = document.getElementById('closeWebsiteButton');

        // New speech response window elements
        const speechPopup = document.getElementById('speechPopup');
        const speechText = document.getElementById('speechText');
        const closeSpeechButton = document.getElementById('closeSpeechButton');

        // Global variables for speech recognition and response functions
        let recognition;
        let statusTimeout; // Timeout for clearing status message
        let currentUtterance = null; // To hold the current speech utterance object
        let displayTimeout = null; // Timeout for sentence display duration

        // Show error message
        function displayError(message) {
            errorText.textContent = message;
            errorMessage.classList.remove('hidden');
        }

        // Show website pop-up
        function showWebsitePopup(url) {
            websiteIframe.src = url;
            websiteOverlay.classList.add('active');
        }

        // Close website pop-up
        function closeWebsitePopup() {
            websiteOverlay.classList.remove('active');
            // Clear iframe content and stop loading
            websiteIframe.src = 'about:blank';
        }

        // Add event listener to close button
        closeWebsiteButton.addEventListener('click', closeWebsitePopup);

        // Text-to-speech function
        function speak(text) {
            if (!('speechSynthesis' in window)) {
                console.warn("Your browser does not support SpeechSynthesis.");
                return;
            }

            // Stop and clear previous speeches
            speechSynthesis.cancel();
            if (currentUtterance) {
                currentUtterance.onend = null;
                currentUtterance = null;
            }
            clearTimeout(displayTimeout); // Clear previous display timer

            const urlRegex = /(https?:\/\/[^\s]+)|((?:www\.)?[a-z0-9-]+\.[a-z]{2,6}(?:\/[^\s]*)?)/gi;
            const filteredText = text.replace(urlRegex, '');

            // Split into phrases (by punctuation or multiple spaces)
            const phrases = filteredText.split(/(?<=[.!?])\s+|\s{2,}/).filter(p => p.trim() !== '');
            
            let currentPhraseIndex = 0;

            // Function to speak and display a single phrase
            function speakSinglePhrase(phrase) {
                // Clear previous animations
                speechText.classList.remove('slide-in', 'slide-out');
                speechText.textContent = phrase;
                speechText.classList.add('slide-in'); // Apply slide-in for the new phrase

                // Calculate display duration based on word count (1 second per word)
                const words = phrase.split(/\s+/).filter(word => word.length > 0);
                const displayDuration = Math.max(words.length * 1000, 1500); // Minimum 1.5 seconds

                let speechEnded = false;
                let displayTimeElapsed = false;

                // Check and proceed to the next phrase when both speech ends and minimum display duration passes
                const checkAndProceed = () => {
                    if (speechEnded && displayTimeElapsed) {
                        // When both conditions are met, start the animation to transition to the next phrase
                        if (speechText.textContent) { // Only apply animation if text is currently displayed
                            speechText.classList.remove('slide-in');
                            speechText.classList.add('slide-out');
                            speechText.addEventListener('animationend', function handler(event) {
                                if (event.animationName === 'slideOutToRight') {
                                    speechText.removeEventListener('animationend', handler);
                                    processNextPhrase(); // Process the next phrase after animation completes
                                }
                            }, { once: true });
                        } else {
                            processNextPhrase(); // If no text, directly process the next phrase
                        }
                    }
                };

                currentUtterance = new SpeechSynthesisUtterance(phrase);
                currentUtterance.lang = 'tr-TR';

                currentUtterance.onend = () => {
                    speechEnded = true;
                    checkAndProceed();
                };

                currentUtterance.onerror = (event) => {
                    console.error('Speech synthesis error:', phrase, event.error);
                    speechEnded = true; // Consider speech ended even on error
                    checkAndProceed();
                };

                speechSynthesis.speak(currentUtterance);

                clearTimeout(displayTimeout);
                displayTimeout = setTimeout(() => {
                    displayTimeElapsed = true;
                    checkAndProceed();
                }, displayDuration); // Set timer for display duration
            }

            // Function to manage the sequence of phrases and animations
            function processNextPhrase() {
                if (currentPhraseIndex < phrases.length) {
                    const phraseToSpeak = phrases[currentPhraseIndex].trim();
                    currentPhraseIndex++;
                    speakSinglePhrase(phraseToSpeak); // Directly speak and display the next phrase
                } else {
                    // All phrases have been processed, hide the popup after a short delay
                    setTimeout(() => {
                        speechPopup.classList.remove('active');
                        speechText.textContent = '';
                        speechText.classList.remove('slide-in', 'slide-out');
                    }, 500);
                }
            }

            // Show the popup and start the process
            speechPopup.classList.add('active');
            processNextPhrase(); // Start with the first phrase
        }

        // Close speech response window button
        closeSpeechButton.addEventListener('click', () => {
            speechSynthesis.cancel(); // Stop speech
            if (currentUtterance) {
                currentUtterance.onend = null;
                currentUtterance = null;
            }
            clearTimeout(displayTimeout); // Clear display timer
            // Stop ongoing animations and reset classes
            speechText.classList.remove('slide-in', 'slide-out');
            speechPopup.classList.remove('active');
            speechText.textContent = '';
        });


        // Initialize speech recognition
        function initializeSpeechRecognition() {
            // Check if browser supports SpeechRecognition API
            if (!('SpeechRecognition' in window || 'webkitSpeechRecognition' in window)) {
                voiceStatus.textContent = "Sorry, your browser does not support speech recognition.";
                return;
            }

            // Check if browser supports microphone and media devices API
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                voiceStatus.textContent = "Your browser does not support microphone access.";
                return;
            }

            // Check microphone permission status
            navigator.permissions.query({ name: 'microphone' }).then((permissionStatus) => {
                if (permissionStatus.state === 'granted') {
                    // If permission is already granted, start speech recognition directly
                    voiceStatus.textContent = "Microphone permission granted. Starting listening...";
                    startRecognition();
                } else if (permissionStatus.state === 'denied') {
                    // If permission is denied, tell the user to enable it manually
                    voiceStatus.textContent = "Microphone permission denied. Voice commands are unavailable. Please enable it manually in your browser settings.";
                    // Removed speak() call to prevent "Speech synthesis error" in this scenario
                } else {
                    // If permission state is 'prompt' or 'undefined', request permission
                    voiceStatus.textContent = "Waiting for microphone permission...";
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(() => {
                            voiceStatus.textContent = "Microphone permission granted. Starting listening...";
                            startRecognition();
                        })
                        .catch((err) => {
                            console.error("Microphone permission denied or error occurred:", err);
                            voiceStatus.textContent = "Microphone permission denied. Voice commands are unavailable. Please enable it manually in your browser settings.";
                            // Removed speak() call to prevent "Speech synthesis error" in this scenario
                        });
                }
            }).catch((err) => {
                console.error("Error querying microphone permission status:", err);
                voiceStatus.textContent = "Could not check microphone permission status. Please check your browser settings.";
                // Removed speak() call to prevent "Speech synthesis error" in this scenario
            });

            function startRecognition() {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.continuous = true; // Continuous listening
                recognition.interimResults = false; // Do not show interim results, for more stable results
                recognition.lang = 'tr-TR'; // Set Turkish language

                // When speech recognition starts
                recognition.onstart = () => {
                    voiceStatus.textContent = "Listening...";
                    console.log("Speech recognition started.");
                };

                // When speech recognition ends
                recognition.onend = () => {
                    console.log("Speech recognition stopped. Restarting.");
                    voiceStatus.textContent = "Listening stopped. Restarting...";
                    // Automatically restart listening
                    recognition.start();
                };

                // When speech recognition result comes
                recognition.onresult = async (event) => {
                    let finalTranscript = '';

                    // Get only final results
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        const result = event.results[i];
                        if (result.isFinal) {
                            finalTranscript += result[0].transcript;
                        }
                    }

                    if (finalTranscript.length > 0) {
                        const transcript = finalTranscript.toLowerCase().trim();
                        console.log("Detected speech (final):", transcript);

                        // Clear previous status
                        if (statusTimeout) {
                            clearTimeout(statusTimeout);
                        }
                        
                        let queryToProcess = transcript; // Process the entire transcript

                        voiceStatus.textContent = `Detected: "${queryToProcess}" is being processed...`;
                        
                        // Directly call the search function, allow AI to process the response
                        if (queryToProcess.length > 0) {
                            searchInput.value = queryToProcess; // Write to search box
                            performSearch(queryToProcess); // Call performSearch directly instead of clicking search button
                        }
                    }
                };

                // When speech recognition error occurs
                recognition.onerror = (event) => {
                    console.error("Speech recognition error:", event.error);
                    voiceStatus.textContent = `Error: ${event.error}. Please check microphone permission.`;
                    speak("An error occurred in speech recognition.");
                    // Reset status message after a while even on error
                    if (statusTimeout) {
                        clearTimeout(statusTimeout);
                    }
                    statusTimeout = setTimeout(() => {
                        voiceStatus.textContent = "Listening...";
                    }, 5000); // Longer duration for error message
                };

                // Start listening
                recognition.start();
            }
        }

        // Function to process voice commands (Gemini API integration)
        async function processVoiceCommand(command) {
            // This function will now directly perform a search.
            // Special cases like greetings will be handled by the AI.
            // We only handle website opening commands here.
            const openWebsiteKeywords = {
                "youtube aç": "https://www.youtube.com",
                "google aç": "https://www.google.com",
                "slow roads aç": "https://slowroads.io",
                "x aç": "https://x.com",
                "spotify aç": "https://www.spotify.com",
                "arama motorunu aç": "yzeka.html" // Redirect to search engine
            };

            for (const key in openWebsiteKeywords) {
                if (command.includes(key)) {
                    const url = openWebsiteKeywords[key];
                    const blockedDomains = ['youtube.com', 'google.com', 'facebook.com', 'instagram.com', 'twitter.com', 'x.com', 'spotify.com'];
                    const isBlocked = blockedDomains.some(domain => url.includes(domain));

                    voiceStatus.textContent = `"${key}" command detected. Opening ${url}...`;
                    speak(`${key} açılıyor.`);

                    if (isBlocked) {
                        let countdown = 3;
                        voiceStatus.textContent += ` This site cannot be previewed due to security policies. Opening in a new tab... in ${countdown} seconds.`;
                        const interval = setInterval(() => {
                            countdown--;
                            if (countdown > 0) {
                                voiceStatus.textContent = `This site cannot be previewed due to security policies. Opening in a new tab... in ${countdown} seconds.`;
                            } else {
                                clearInterval(interval);
                                window.open(url, '_blank');
                                voiceStatus.textContent = `This site opened in a new tab due to security policies.`;
                            }
                        }, 1000);
                    } else {
                        // If redirecting to yzeka.html, redirect directly
                        if (url === 'yzeka.html') {
                            window.location.href = url;
                        } else {
                            showWebsitePopup(url); // Show pop-up for other sites
                        }
                    }
                    return true; // Command handled
                }
            }
            return false; // Command not specifically handled
        }


        // Search function
        async function performSearch(voiceQuery = null) { // voiceQuery parameter added
            const query = voiceQuery || searchInput.value.trim(); // Use voice query if available, otherwise get from input
            if (!query) {
                displayError("Please enter a search term.");
                // Reset button state
                searchButton.disabled = false;
                buttonText.classList.remove('hidden');
                loadingSpinner.classList.add('hidden');
                return;
            }

            // UI updates when search starts
            searchButton.disabled = true;
            buttonText.classList.add('hidden');
            loadingSpinner.classList.remove('hidden');
            resultsDiv.innerHTML = ''; // Clear previous web results
            aiResponseDiv.innerHTML = ''; // Clear previous AI response
            noResultsMessage.classList.add('hidden');
            errorMessage.classList.add('hidden');
            voiceStatus.textContent = `Searching for response for "${query}"...`;
            speak("Searching for response.");


            try {
                // 1. Generate AI Response (using Gemini API)
                aiResponseDiv.innerHTML = `
                    <div class="result-card bg-blue-50 border-blue-200">
                        <h3 class="result-title text-blue-800 text-xl mb-2">✨ AI Response</h3>
                        <p class="text-center text-gray-500">Generating AI response...</p>
                    </div>
                `;
                let chatHistory = [];
                // New instructions added to AI:
                // - Provide a medium-length, informative response.
                // - If asked who you are, respond "I am Femi."
                // - State that you do not have image generation capabilities.
                // - When receiving a command to open/visit a website (e.g., "open YouTube", "go to Google", "open slow roads", "open x"), the response should only be the URL of that website (e.g., "https://www.youtube.com", "https://www.google.com", "https://slowroads.io", "https://x.com"). Do not add any other text. Just provide the URL.
                // - In other cases, provide a short, informative, and concise response to the user's search query.
                chatHistory.push({ role: "user", parts: [{ text: `Provide a medium-length, informative response. If asked who you are, respond "I am Femi.". Do not mention image generation or media processing capabilities. If you receive a command to open or visit a website (e.g., "YouTube aç", "Google'a git", "slow roads aç", "x aç"), your response should only be the URL of that website (e.g., "https://www.youtube.com", "https://www.google.com", "https://slowroads.io", "https://x.com"). Do not add any other text. Just provide the URL. Provide a short, informative, and concise response to the user's search query: "${query}"` }] });
                const payload = { contents: chatHistory };
                // Paste your Gemini API key here.
                const apiKey = "AIzaSyAng0nZ5N8ZyQmNLkVhf0HZbziVXBa_Xbw";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        let aiText = result.candidates[0].content.parts[0].text;
                        // Add an additional sentence to the AI response
                        aiText += " İstediğini sor, konuşmaktan çekinme.";

                        // Search for URL in AI response
                        // Catch both http/https and www-starting URLs, as well as domain.tld format URLs
                        const urlRegex = /(https?:\/\/[^\s]+)|((?:www\.)?[a-z0-9-]+\.[a-z]{2,6}(?:\/[^\s]*)?)/gi;
                        const foundUrls = aiText.match(urlRegex);

                        let suggestedUrl = null;
                        if (foundUrls && foundUrls.length > 0) {
                            suggestedUrl = foundUrls[0];
                            // If URL does not start with http or https, add https
                            if (!suggestedUrl.startsWith('http://') && !suggestedUrl.startsWith('https://')) {
                                suggestedUrl = 'https://' + suggestedUrl;
                            }
                            console.log("Detected URL:", suggestedUrl); // Log the detected URL to console

                            // Known sites that cannot be displayed in iframe
                            const blockedDomains = ['youtube.com', 'google.com', 'facebook.com', 'instagram.com', 'twitter.com', 'x.com', 'spotify.com'];
                            const isBlocked = blockedDomains.some(domain => suggestedUrl.includes(domain));

                            // Always display AI response
                            aiResponseDiv.innerHTML = `
                                <div class="result-card bg-blue-50 border-blue-200">
                                    <h3 class="result-title text-blue-800 text-xl mb-2">✨ Yapay Zeka Yanıtı</h3>
                                    <p class="result-snippet text-blue-700">${aiText}</p>
                                </div>
                            `;
                            speak(aiText); // Speak AI response

                            // If site is blocked, open in new tab, otherwise show in pop-up
                            if (isBlocked) {
                                let countdown = 3;
                                aiResponseDiv.innerHTML += `
                                    <p id="countdownMessage" class="mt-3 text-gray-600">Bu site güvenlik politikaları nedeniyle önizlenemiyor. Yeni sekmede açılıyor... ${countdown} saniye içinde.</p>
                                `;
                                const countdownElement = document.getElementById('countdownMessage');

                                const interval = setInterval(() => {
                                    countdown--;
                                    if (countdown > 0) {
                                        countdownElement.textContent = `Bu site güvenlik politikaları nedeniyle önizlenemiyor. Yeni sekmede açılıyor... ${countdown} saniye içinde.`;
                                    } else {
                                        clearInterval(interval);
                                        window.open(suggestedUrl, '_blank');
                                        countdownElement.textContent = `Bu site güvenlik politikaları nedeniyle yeni sekmede açıldı.`;
                                    }
                                }, 1000);

                            } else {
                                showWebsitePopup(suggestedUrl); // If URL found, directly show pop-up
                            }
                        } else {
                            aiResponseDiv.innerHTML = `
                                <div class="result-card bg-blue-50 border-blue-200">
                                    <h3 class="result-title text-blue-800 text-xl mb-2">✨ Yapay Zeka Yanıtı</h3>
                                    <p class="result-snippet text-blue-700">${aiText}</p>
                                </div>
                            `;
                            speak(aiText); // Speak AI response
                        }
                    } else {
                        aiResponseDiv.innerHTML = '<p class="text-center text-gray-500">AI response could not be retrieved.</p>';
                    }
                } catch (aiError) {
                    console.error("AI response error:", aiError);
                    // If API call fails, show mock response
                    aiResponseDiv.innerHTML = `
                        <div class="result-card bg-blue-50 border-blue-200">
                            <h3 class="result-title text-blue-800 text-xl mb-2">✨ Yapay Zeka Yanıtı (Mock)</h3>
                            <p class="result-snippet text-blue-700">Merhaba! Ben Femi. Sorgunla ilgili bilgi veremiyorum çünkü yapay zeka servisine erişilemiyor. Lütfen API anahtarını kontrol et ve daha sonra tekrar dene. Eğer bir web sitesi önerisi bekliyorsan, şu an için doğrudan açamıyorum.</p>
                        </div>
                    `;
                    speak("Sorry, AI response could not be retrieved. Please try again later.");
                }

                // 2. Web Search Results (using google_search tool)
                if (typeof google_search !== 'undefined' && typeof google_search.search === 'function') {
                    const searchResults = await google_search.search(queries=[query, query + " search"]);

                    if (searchResults && searchResults.length > 0 && searchResults[0].results) {
                        const results = searchResults[0].results;
                        if (results.length === 0) {
                            noResultsMessage.classList.remove('hidden');
                        } else {
                            results.forEach((result, index) => {
                                const resultCard = document.createElement('div');
                                // Added initial classes for animation
                                resultCard.className = 'result-card opacity-0 translate-y-5 transition-all duration-500 ease-out';

                                const title = document.createElement('h3');
                                title.className = 'result-title text-lg mb-1';
                                title.textContent = result.source_title || 'No Title';

                                const url = document.createElement('a');
                                url.className = 'result-url block mb-2';
                                url.href = result.url || '#';
                                url.target = '_blank'; // Open in new tab
                                url.textContent = result.url || 'No URL';

                                const snippet = document.createElement('p');
                                snippet.className = 'result-snippet';
                                snippet.textContent = result.snippet || 'Description not available.';

                                resultCard.appendChild(title);
                                resultCard.appendChild(url);
                                resultCard.appendChild(snippet);
                                resultsDiv.appendChild(resultCard);

                                // Start animation for each card with a slight delay
                                setTimeout(() => {
                                    resultCard.classList.remove('opacity-0', 'translate-y-5');
                                    resultCard.classList.add('opacity-100', 'translate-y-0');
                                }, index * 100); // 100ms delay for each card
                            });
                        }
                    } else {
                        noResultsMessage.classList.remove('hidden');
                    }
                } else {
                    resultsDiv.innerHTML = '';
                }

            } catch (mainError) {
                console.error("General search error:", mainError);
                displayError(mainError.message || "A general error occurred during search. Please try again.");
            } finally {
                // UI updates when search ends
                searchButton.disabled = false;
                buttonText.classList.remove('hidden');
                loadingSpinner.classList.add('hidden');
                // Clear search input
                searchInput.value = '';
                console.log("performSearch finished, button re-enabled."); // To check if function finished
            }
        }

        // Listen for click event on search button
        searchButton.addEventListener('click', performSearch);

        // Perform search on Enter key press
        searchInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                performSearch();
    
       }
        });

        // Start speech recognition when page loads
        window.addEventListener('load', initializeSpeechRecognition);
    </script>
</body>
</html>
